/*
 Copyright 2014 John Duane. All rights reserved.
 Use of this source code is governed by a BSD-style license that can be
 found in the LICENSE file.

 The following code processes a file type of "cpuprofile" generated by Chrome's developer tools.
 The intent is to expose a simplified version of the file that rolls up all unique combination of url and function
 into a single object that contains the time spent in that function.

 The code takes as input the path to a cpuprofile file and generates a 'profileHash' object containing:
 - Object hash key of url|function
 - url: string; typically to a JavaScript file
 - function: string; typically a minified function name
 - time: number; the total cpu time spent in the function

 */

module.exports = Har;

var fs = require('fs');

function Har(filePath) {
    var file = fs.readFileSync(filePath);
    if (!file) {
        file = fs.readFileSync(path.join(__dirname, filePath));
    }
    if (!file) {
        file = fs.readFileSync(path.join(process.cwd(), filePath));
    }
    if (!file) throw ({message:"Can't process har file: " + filePath});

    var har = JSON.parse(file);

    if (har && har.log && har.log.entries) {
        this.harJs = {fileProcessed: filePath, pages: har.log.pages};
        this._processEntries(har.log.entries);
    }
    else {
        this.harJs = null;
        throw({message:"Can't process har file: " + filePath});
    }
}

Har.prototype = {

    generateDetails: function() {
        var tsv = "HAR file: " + this.harJs.fileProcessed + "\n\n" +
                  "Page\tURL\tTotal Request Time\tContent Type\tEncoding\tUncompressed\tCompressed\n";
        for(var i = 0; i < this.harJs.entries.length; i++) {
            tsv +=
                this.harJs.entries[i].page + "\t" +
                this.harJs.entries[i].url + "\t" +
                this.harJs.entries[i].time + "\t" +
                this.harJs.entries[i].contentType + "\t" +
                this.harJs.entries[i].encoding + "\t" +
                this.harJs.entries[i].content.size + "\t" +
                (this.harJs.entries[i].content.size - this.harJs.entries[i].content.compression) + "\n";
                //TODO: write other timings
        }
        return tsv;
    },

    generateSummary: function() {
        var i, j, totalTime, totalJsFiles, totalCompressed, totalUncompressed;
        var tsvJS = "HAR file: " + this.harJs.fileProcessed + "\n\n" +
            "Page\tCount of .js files\tTotal Request Time\n";
        var tsvCompression = "Page\t# Compressed\t# Uncompressed\n";
        for (i = 0; i < this.harJs.pages.length; i++) {
            totalTime = totalJsFiles = totalCompressed = totalUncompressed = 0;
            for (j = 0; j < this.harJs.entries.length; j++) {
                if (this.harJs.pages[i].title === this.harJs.entries[j].page) {
                    if (this.harJs.entries[j].isEntryJavaScript) {
                        totalJsFiles++;
                        totalTime += this.harJs.entries[j].time;
                    }
                    if (this.harJs.entries[j].encoding) {
                        totalCompressed++;
                    }
                    else {
                        totalUncompressed++;
                    }
                }
            }
            tsvJS +=
                this.harJs.pages[i].title + "\t" +
                totalJsFiles + "\t" +
                totalTime + "\n";
            tsvCompression +=
                this.harJs.pages[i].title + "\t" +
                totalCompressed + "\t" +
                totalUncompressed + "\n";

        }
        return tsvJS + "\n" + tsvCompression;
    },

    _processEntries: function(entries) {
        var i;
        if (Array.isArray(entries)) {
            this.harJs.entries = [];
            for (i = 0; i < entries.length; i++) {
                    this.harJs.entries.push({
                        page: getEntryPage(this.harJs.pages, entries[i].pageref),
                        url: entries[i].request.url,
                        isEntryJavaScript: isEntryJavaScript(entries[i].response.headers),
                        time: entries[i].time,
                        encoding: getResponseHeaderValue(entries[i].response.headers, "content-encoding"),
                        contentType: getResponseHeaderValue(entries[i].response.headers, "Content-Type"),
                        content: entries[i].response.content
                        //TODO: get other timings
                    });
            }
        }

        function getResponseHeaderValue(headers, name) {
            var i, value = null;
            for (i = 0; i < headers.length && !value; i++) {
                if (headers[i].name.toLocaleLowerCase() === name.toLocaleLowerCase())
                    value = headers[i].value;
            }
            return value;
        }

        function isEntryJavaScript(headers) {
            var i, found = false;
            for (i = 0; i < headers.length && !found; i++) {
                if (headers[i].value.indexOf('javascript') !== -1 )
                    found = true;
            }
            return found;
        }

        function getEntryPage(pages, pageRef) {
            var i, foundPage = null;
            for (i = 0; i < pages.length && !foundPage; i++) {
                if (pages[i].id === pageRef)
                    foundPage = pages[i].title;
            }
            return foundPage;
        }
    }

};
